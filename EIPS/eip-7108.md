---
eip: 7108
title: Clustered ERC-721
description: Extend ERC-721 to allow for clusters of NFTs ad sub-collections
author: Francesco Sullo (@sullof)
discussions-to: https://ethereum-magicians.org/t/clustered-nft-for-sub-collections/14502
status: Draft
type: Standards Track
category: ERC
created: 2023-05-30
requires: 165, 721
---

## Abstract

A standard interface for contracts that manage clusters or sub-collections of [ERC-721](./eip-721) tokens within a single contract.

This EIP introduces a new standard interface for Ethereum contracts that manage multiple clusters or sub-collections of [ERC-721](./eip-721) tokens within a single contract. This allows the tokens to be grouped together in a way that maintains each group's distinct identity and metadata.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

A contract that includes this interface must implement the [ERC-721](./eip-721) interface and adhere to the same specifications and restrictions. Additionally, it must implement the following functions:

```solidity
/**
 * @title IERC7108
 * @dev This interface allows managing clusters or sub-collections of ERC721 tokens within a single contract
 */
interface IERC7108 {
  /**
   * @dev Emitted when a new cluster is added
   */
  event ClusterAdded(uint256 indexed clusterId, string name, string symbol, string baseTokenURI, uint256 size, address owner);

  /**
   * @dev Emitted when ownership of a cluster is transferred
      The interface does not specify functions to transfer the ownership of the cluster
      to leave the implementer full freedom about how to implement it, with the only
      requirement that a ClusterOwnershipTransferred event MUST be emitted if so
   */
  event ClusterOwnershipTransferred(uint256 indexed clusterId, address indexed newOwner);

  /**
   * @notice Gets the id of the cluster to which a token belongs
   * @param tokenId ID of the token
   * @return uint256 ID of the cluster to which the token belongs
   */
  function clusterOf(uint256 tokenId) external view returns (uint256);

  /**
   * @notice Gets the name of a cluster
   * @param clusterId ID of the cluster
   * @return string Name of the cluster
   */
  function nameOf(uint256 clusterId) external view returns (string memory);

  /**
   * @notice Gets the symbol of a cluster
   * @param clusterId ID of the cluster
   * @return string Symbol of the cluster
   */
  function symbolOf(uint256 clusterId) external view returns (string memory);

  /**
   * @notice Gets the range of token IDs that are included in a specific cluster
   * @param clusterId ID of the cluster
   * @return (uint256, uint256) Start and end of the token ID range
   */
  function rangeOf(uint256 clusterId) external view returns (uint256, uint256);

  /**
   * @notice Gets the owner of a cluster
   * @param clusterId ID of the cluster
   * @return address Owner of the cluster
   */
  function clusterOwner(uint256 clusterId) external view returns (address);

  /**
   * @notice Gets how many clusters have been added
   * @return uint256 Total number of clusters
   */
  function clustersCount() external view returns (uint256);

  /**
   * @notice Adds a new cluster
   * @dev The ClusterAdded event MUST be emitted upon successful execution
   * @param name Name of the cluster
   * @param symbol Symbol of the cluster
   * @param baseTokenURI Base Token URI of the cluster
   * @param size Size of the cluster (number of tokens)
   * @param clusterOwner Address of the cluster owner
   */
  function addCluster(
    string memory name,
    string memory symbol,
    string memory baseTokenURI,
    uint256 size,
    address clusterOwner
  ) external;

  /**
   * @notice Gets the normalized token ID for a token
   * @dev The normalized token ID is the token ID within the cluster, starting from 1
   * @param tokenId ID of the token
   * @return uint256 Normalized token ID
   */
  function normalizedTokenId(uint256 tokenId) external view returns (uint256);

}
```

### Enumerable extension 

It is convenient to have a function to retrieve the balance of a wallet within a specific cluster. However, a standard [ERC-721](./eip-721) may not be able to return that value, because the implementation may require that the NFT is enumerable. For this reason, the following function is set in a separate interface, which should be implemented with [ERC-7108](./eip-7108) to retrieve the balance of a wallet within a specific cluster.

```solidity
/**
 * @title IERC7108Enumerable
 * @dev This is supposed to be used with ERC721Enumerable and ERC7108
 */
interface IERC7108Enumerable {

  /**
   * @notice Retrieves the balance of tokens a wallet owns within a specific cluster
   * @dev The balance is the number of tokens owned by the caller within the specified cluster.
      Note that due to potential computational complexity, this function could be gas-intensive,
      and therefore should only be called from dApps rather than internally
      or from other smart contracts.
   * @param owner The owner of the tokens
   * @param clusterId ID of the cluster
   * @return uint256 Balance of tokens within the cluster
   */
  function balanceOfWithin(address owner, uint256 clusterId) external view returns(uint);
}
```

## Rationale

Non-fungible tokens (NFTs) have demonstrated their transformative potential by redefining ownership of digital and physical assets in a decentralized manner. As these tokens gain traction, the need to manage multiple categories or groups of NFTs within a single contract has arisen, presenting challenges due to the unique nature of each token. We propose a standard interface that eases the management of such grouped NFTs, fostering an organized environment where collections of NFTs can be logically grouped together under a common theme or characteristic without compromising their unique identity and metadata.

The introduction of the concept of "clusters" is at the heart of this EIP. A cluster represents a sub-collection or group of NFTs within a larger contract. This allows for finer categorization and management of tokens, enhancing user navigation and interaction. For instance, an online game could leverage this standard to allow players to create their unique collections of in-game assets, each represented as a separate cluster.

Moreover, the financial implications of deploying new contracts for distinct collections can be a barrier to developers, particularly those with limited resources. This EIP alleviates this challenge by enabling a single contract to manage an infinite number of clusters, thereby streamlining the process of creating new collections. This mirrors the functionality provided by prominent marketplaces such as OpenSea or SuperRare, which support lazy-minting by facilitating the creation of multiple unique tokens within a single contract.

Beyond the benefits for developers, this EIP has profound implications for non-developer users. The addCluster function empowers users to create their own collections without writing any code. This democratization of collection creation could spur a new wave of creativity and participation in the NFT space.

Furthermore, this EIP is significant for its potential applications in various domains. For instance, it could be utilized to manage affiliation programs, where each affiliate is assigned a unique cluster, simplifying the tracking and management process. Similarly, it could facilitate the generation of versioned collections, where each version is assigned to a different cluster, thereby maintaining a clear and organized representation of each version.

On a broader level, this EIP could help decentralize the approach to lazy-minting collections, providing a general direction for marketplaces. It opens up the possibility for a multitude of innovative use cases, from creating limited editions or seasonal collections to organizing event-specific tokens, and much more.

In conclusion, this proposal offers a more flexible, efficient, and democratic approach to managing NFT collections. By introducing the concept of clusters, it simplifies the process for developers, enables non-developer users to participate in the creation of collections, and provides a framework for more organized and easily navigable collections, while preserving the unique attributes of each token. The potential use cases and implications of this standard underline its relevance and necessity in the evolving NFT space.

## Backwards Compatibility

This EIP is fully backwards compatible with the existing [ERC-721](./eip-721) standard. A contract that implements [ERC-7108](./eip-7108) also implements [ERC-721](./eip-721).


## Reference Implementation

There is an example of implementation of this interface in [this directory](../assets/eip-7108).

## Security Considerations

Given that a single contract under this standard allows for the creation of an unlimited number of sub-collections, each mintable by their respective cluster owners, it's crucial for marketplaces and other interacting entities to accurately distinguish between these sub-collections. Each sub-collection should be treated as a distinct entity, rather than conflating them as part of a single collection.

This distinction is essential for maintaining the security and integrity of the contract, as it helps to prevent unauthorized actions across different clusters. Misidentifying clusters can lead to unintentional access permissions, faulty transactions, or incorrect display of data. Therefore, it is highly recommended that adequate measures are taken to ensure proper identification and handling of the individual sub-collections within a contract.

Additionally, developers implementing this interface should take extra precautions in their permissions system to make sure that only the rightful cluster owners are allowed to mint tokens in their respective clusters. Robust implementation of access controls is critical in avoiding potential security vulnerabilities associated with unauthorized minting.

Finally, the contract, may want to avoid that two clusters share the same name or the same baseTokenURI, etc. to avoid scams.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
